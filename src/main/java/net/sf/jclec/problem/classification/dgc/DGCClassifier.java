package net.sf.jclec.problem.classification.dgc;

import java.util.ArrayList;

import net.sf.jclec.problem.classification.classic.ClassicInstance;
import net.sf.jclec.problem.classification.classic.IClassicClassifier;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.IExample;
import net.sf.jclec.problem.util.dataset.IMetadata;

public class DGCClassifier implements IClassicClassifier
{	
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 1L;
	
	private double[] weights;

	private DGCSpecies species;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	public DGCClassifier(DGCSpecies species)
	{
		super();
		
		this.species = species;
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	 /**
     * Obtain the number of conditions from the classifier
     * 
     * @return number of conditions
     */
	public int getConditions()
	{
		return 0;
	}
	
	public double[] getWeights()
	{
		return weights;
	}
	
	public void setWeights(double[] weights)
	{
		this.weights = weights;
	}
	
	@Override
	public String toString(IMetadata metadata)
	{
		return new String();
	}
	
	/**
	 * Obtains the confusion matrix for a dataset
	 * @param data the dataset
	 * @return the confusion matrix
	 */
	
	public int[][] getConfusionMatrix(IDataset dataset)
	{
		IMetadata metadata = dataset.getMetadata();
		int [][] confusionMatrix = new int[metadata.numberOfClasses()][metadata.numberOfClasses()];
		
		double[] predicted = classify(dataset);
		
		for(int i = 0; i < dataset.getExamples().size(); i++) 
    	{
			confusionMatrix[(int) ((ClassicInstance) dataset.getExamples().get(i)).getClassValue()][(int) predicted[i]]++;
    	}
		
		return confusionMatrix;
	}

	public double classify(IExample inst)
	{
		double maxGravity = -1;
		int maxGravityClass = 0;

		for(int i = 0; i < species.getDataset().getMetadata().numberOfClasses(); i++)
		{
			double gravity = gravity(inst, i);
			
			if(gravity > maxGravity)
			{
				maxGravity = gravity;
				maxGravityClass = i;
			}
		}
		
		return maxGravityClass;
	}
	
	public double[] classify(IDataset dataset)
	{
		ArrayList<IExample> instances = dataset.getExamples();
		double[] predicted = new double[instances.size()];
		
		for(int i = 0; i < instances.size(); i++)
			predicted[i] = classify(instances.get(i));
		
		return predicted;		
	}
	
	public double gravity(IExample inst, int Class)
	{
		ArrayList<IExample> instances = species.getDataset().getExamples();
		
		double gravity = 0.0;
		
		for(int i = 0; i < instances.size(); i++)
			if(((ClassicInstance) instances.get(i)).getClassValue() == Class && instances.get(i) != inst)
				gravity += ((ClassicInstance) instances.get(i)).getWeight() / distance(inst, instances.get(i));
		
		return gravity;
	}
	
	private double distance(IExample inst1, IExample inst2)
	{
		int numAttributes = ((ClassicInstance) inst1).getValues().length - 1;
		
		double distance = 0.0;
		
		if(weights != null)
			for(int i = 0; i < numAttributes; i++)
				distance += weights[i] * Math.pow((inst2.getValue(i) - inst1.getValue(i)) / species.getRange(i), 2);
		else
			for(int i = 0; i < numAttributes; i++)
				distance += Math.pow((inst2.getValue(i) - inst1.getValue(i)) / species.getRange(i), 2);
		
		return distance;
	}

	@Override
	public DGCClassifier copy()
	{
		return new DGCClassifier(species);
	}
}